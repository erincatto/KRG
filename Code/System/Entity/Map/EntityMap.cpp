#include "EntityMap.h"
#include "System/Resource/ResourceSystem.h"
#include "System/Entity/Entity.h"
#include "System/Core/Profiling/Profiling.h"

//-------------------------------------------------------------------------

namespace KRG::EntityModel
{
    EntityMap::EntityMap()
        : EntityCollection()
        , m_entityUpdateEventBindingID( Entity::OnEntityStateUpdated().Bind( [this] ( Entity* pEntity ) { OnEntityStateUpdated( pEntity ); } ) )
        , m_isTransientMap( true )
    {
        m_ID.Reset(); // Clear autogenerated ID
    }

    EntityMap::EntityMap( ResourceID mapResourceID )
        : EntityCollection()
        , m_pMapDesc( mapResourceID )
        , m_entityUpdateEventBindingID( Entity::OnEntityStateUpdated().Bind( [this] ( Entity* pEntity ) { OnEntityStateUpdated( pEntity ); } ) )
    {
        m_ID.Reset(); // Clear autogenerated ID
    }

    EntityMap::EntityMap( EntityMap const& map )
        : m_entityUpdateEventBindingID( Entity::OnEntityStateUpdated().Bind( [this] ( Entity* pEntity ) { OnEntityStateUpdated( pEntity ); } ) )
    {
        operator=( map );
    }

    EntityMap::EntityMap( EntityMap&& map )
        : m_entityUpdateEventBindingID( Entity::OnEntityStateUpdated().Bind( [this] ( Entity* pEntity ) { OnEntityStateUpdated( pEntity ); } ) )
    {
        operator=( eastl::move( map ) );
    }

    EntityMap::~EntityMap()
    {
        KRG_ASSERT( IsUnloaded() && !m_isCollectionInstantiated );
        KRG_ASSERT( m_entities.empty() && m_entityLookupMap.empty() );
        Entity::OnEntityStateUpdated().Unbind( m_entityUpdateEventBindingID );
    }

    //-------------------------------------------------------------------------

    EntityMap& EntityMap::operator=( EntityMap const& map )
    {
        // Only allow copy constructor for unloaded maps
        KRG_ASSERT( m_status == Status::Unloaded && map.m_status == Status::Unloaded );

        m_pMapDesc = map.m_pMapDesc;
        const_cast<bool&>( m_isTransientMap ) = map.m_isTransientMap;
        return *this;
    }

    EntityMap& EntityMap::operator=( EntityMap&& map )
    {
        m_ID = map.m_ID;
        m_entities.swap( map.m_entities );
        m_entityLookupMap.swap( map.m_entityLookupMap );
        m_pMapDesc = eastl::move( map.m_pMapDesc );
        m_entitiesToLoad = eastl::move( map.m_entitiesToLoad );
        m_reloadRequests = eastl::move( map.m_reloadRequests );
        m_status = map.m_status;
        m_isUnloadRequested = map.m_isUnloadRequested;
        m_isCollectionInstantiated = map.m_isCollectionInstantiated;
        const_cast<bool&>( m_isTransientMap ) = map.m_isTransientMap;

        // Clear source map
        map.m_ID.Reset();
        map.m_status = Status::Unloaded;
        map.m_isCollectionInstantiated = false;
        map.m_isUnloadRequested = false;
        return *this;
    }

    //-------------------------------------------------------------------------

    void EntityMap::AddEntity( Entity* pEntity )
    {
        // Ensure that the entity to add, is not already part of a collection and that it's deactivated
        KRG_ASSERT( pEntity != nullptr && !pEntity->IsInCollection() && !pEntity->HasRequestedComponentLoad() );
        KRG_ASSERT( !VectorContains( m_entitiesToAdd, pEntity ) );

        // Lock the map
        Threading::RecursiveScopeLock lock( m_mutex );
        m_entitiesToAdd.emplace_back( pEntity );
    }

    Entity* EntityMap::RemoveEntity( UUID entityID )
    {
        Entity* pEntityToRemove = nullptr;

        // Lock the map
        Threading::RecursiveScopeLock lock( m_mutex );

        // Check if the entity is in the add queue, if so just cancel the request
        int32 const entityIdx = VectorFindIndex( m_entitiesToAdd, entityID, [] ( Entity* pEntity, UUID entityID ) { return pEntity->GetID() == entityID; } );
        if ( entityIdx != InvalidIndex )
        {
            pEntityToRemove = m_entitiesToAdd[entityIdx];
            m_entitiesToAdd.erase_unsorted( m_entitiesToAdd.begin() + entityIdx );
        }
        else // Queue removal
        {
            if ( m_isCollectionInstantiated )
            {
                pEntityToRemove = FindEntity( entityID );
                KRG_ASSERT( pEntityToRemove != nullptr );
                m_entitiesToRemove.emplace_back( RemovalRequest( pEntityToRemove, false ) );
            }
            else // Unknown entity
            {
                KRG_UNREACHABLE_CODE();
            }
        }

        return pEntityToRemove;
    }

    void EntityMap::DestroyEntity( UUID entityID )
    {
        Entity* pEntityToDestroy = nullptr;

        // Lock the map
        Threading::RecursiveScopeLock lock( m_mutex );

        // Check if the entity is in the add queue, if so just cancel the request
        int32 const entityIdx = VectorFindIndex( m_entitiesToAdd, entityID, [] ( Entity* pEntity, UUID entityID ) { return pEntity->GetID() == entityID; } );
        if ( entityIdx != InvalidIndex )
        {
            pEntityToDestroy = m_entitiesToAdd[entityIdx];
            m_entitiesToAdd.erase_unsorted( m_entitiesToAdd.begin() + entityIdx );
            KRG::Delete( pEntityToDestroy );
        }
        else
        {
            // Queue removal
            if ( m_isCollectionInstantiated )
            {
                pEntityToDestroy = FindEntity( entityID );
                KRG_ASSERT( pEntityToDestroy != nullptr );
                m_entitiesToRemove.emplace_back( RemovalRequest( pEntityToDestroy, true ) );
            }
            else// Unknown entity
            {
                KRG_UNREACHABLE_CODE();
            }
        }
    }

    //-------------------------------------------------------------------------

    void EntityMap::Load( LoadingContext const& loadingContext )
    {
        KRG_ASSERT( Threading::IsMainThread() && loadingContext.IsValid() );
        KRG_ASSERT( m_status == Status::Unloaded );

        Threading::RecursiveScopeLock lock( m_mutex );

        if ( m_isTransientMap )
        {
            m_ID = UUID::GenerateID();
            m_status = Status::Loaded;
            m_isCollectionInstantiated = true;
        }
        else // Request loading of map resource
        {
            loadingContext.m_pResourceSystem->LoadResource( m_pMapDesc );
            m_status = Status::MapLoading;
        }
    }

    void EntityMap::Unload( LoadingContext const& loadingContext )
    {
        KRG_ASSERT( m_status != Status::Unloaded );
        Threading::RecursiveScopeLock lock( m_mutex );
        m_isUnloadRequested = true;
    }

    void EntityMap::Activate( LoadingContext const& loadingContext, EntityModel::ActivationContext& activationContext )
    {
        KRG_PROFILE_SCOPE_SCENE( "Map Activation" );
        KRG_ASSERT( m_status == Status::Loaded );

        //-------------------------------------------------------------------------

        struct EntityActivationTask : public IAsyncTask
        {
            EntityActivationTask( LoadingContext const& loadingContext, EntityModel::ActivationContext& activationContext, TVector<Entity*>& entities )
                : m_loadingContext( loadingContext )
                , m_activationContext( activationContext )
                , m_entities( entities )
            {
                m_SetSize = (uint32) m_entities.size();
            }

            virtual void ExecuteRange( TaskSetPartition range, uint32 threadnum ) override final
            {
                KRG_PROFILE_SCOPE_SCENE( "Activate Entities Task" );

                for ( uint64 i = range.start; i < range.end; ++i )
                {
                    auto pEntity = m_entities[i];
                    if ( pEntity->IsLoaded() )
                    {
                        // Only activate non-spatial and root spatial entities
                        if ( !pEntity->IsSpatialEntity() || !pEntity->HasSpatialParent() )
                        {
                            pEntity->Activate( m_loadingContext, m_activationContext );
                        }
                    }
                }
            }

        private:

            LoadingContext const&                   m_loadingContext;
            EntityModel::ActivationContext&         m_activationContext;
            TVector<Entity*>&                       m_entities;
        };

        //-------------------------------------------------------------------------

        Threading::RecursiveScopeLock lock( m_mutex );

        EntityActivationTask activationTask( loadingContext, activationContext, m_entities );
        loadingContext.m_pTaskSystem->ScheduleTask( &activationTask );
        loadingContext.m_pTaskSystem->WaitForTask( &activationTask );

        m_status = Status::Activated;
    }

    void EntityMap::Deactivate( LoadingContext const& loadingContext, EntityModel::ActivationContext& activationContext )
    {
        KRG_PROFILE_SCOPE_SCENE( "Map Deactivation" );
        KRG_ASSERT( m_status == Status::Activated );

        //-------------------------------------------------------------------------

        struct EntityDeactivationTask : public IAsyncTask
        {
            EntityDeactivationTask( LoadingContext const& loadingContext, EntityModel::ActivationContext& activationContext, TVector<Entity*>& entities )
                : m_loadingContext( loadingContext )
                , m_activationContext( activationContext )
                , m_entities( entities )
            {
                m_SetSize = (uint32) m_entities.size();
            }

            virtual void ExecuteRange( TaskSetPartition range, uint32 threadnum ) override final
            {
                KRG_PROFILE_SCOPE_SCENE( "Deactivate Entities Task" );

                for ( uint64 i = range.start; i < range.end; ++i )
                {
                    auto pEntity = m_entities[i];
                    if ( pEntity->IsActivated() )
                    {
                        if ( !pEntity->IsSpatialEntity() || !pEntity->HasSpatialParent() )
                        {
                            pEntity->Deactivate( m_loadingContext, m_activationContext );
                        }
                    }
                }
            }

        private:

            LoadingContext const&                   m_loadingContext;
            EntityModel::ActivationContext&         m_activationContext;
            TVector<Entity*>&                       m_entities;
        };

        //-------------------------------------------------------------------------

        Threading::RecursiveScopeLock lock( m_mutex );

        EntityDeactivationTask deactivationTask( loadingContext, activationContext, m_entities );
        loadingContext.m_pTaskSystem->ScheduleTask( &deactivationTask );
        loadingContext.m_pTaskSystem->WaitForTask( &deactivationTask );

        m_status = Status::Loaded;
    }

    //-------------------------------------------------------------------------

    void EntityMap::OnEntityStateUpdated( Entity* pEntity )
    {
        if ( pEntity->GetCollectionID() == m_ID )
        {
            KRG_ASSERT( FindEntity( pEntity->GetID() ) );
            Threading::RecursiveScopeLock lock( m_mutex );
            m_entitiesToLoad.emplace_back( pEntity );
        }
    }

    //-------------------------------------------------------------------------

    void EntityMap::ProcessHotReloadRequests( LoadingContext const& loadingContext, EntityModel::ActivationContext& activationContext )
    {
        auto const& entitiesThatRequireReload = loadingContext.m_pResourceSystem->GetUsersThatRequireReload();
        if ( !entitiesThatRequireReload.empty() )
        {
            for ( auto const& requesterID : entitiesThatRequireReload )
            {
                auto pFoundEntity = FindEntity( requesterID.GetID() );
                if ( pFoundEntity != nullptr )
                {
                    m_reloadRequests.emplace_back( ReloadRequest( pFoundEntity ) );
                }
            }
        }

        // We need to have at least a single frame delay between the unload and load requests
        // so that the resource system can actually unload the resource, instead of just canceling the unload request
        for ( int32 i = (int32) m_reloadRequests.size() - 1; i >= 0; i-- )
        {
            auto& request = m_reloadRequests[i];

            if ( request.m_isUnloading )
            {
                if ( request.m_pEntity->IsActivated() )
                {
                    request.m_pEntity->Deactivate( loadingContext, activationContext );
                }
                else
                {
                    request.m_pEntity->UnloadComponents( loadingContext );
                    request.m_isUnloading = false;
                }
            }
            else
            {
                KRG_ASSERT( !request.m_pEntity->IsActivated() );
                request.m_pEntity->LoadComponents( loadingContext );
                m_entitiesToLoad.emplace_back( request.m_pEntity );
                m_reloadRequests.erase_unsorted( m_reloadRequests.begin() + i );
            }
        }
    }

    bool EntityMap::ProcessUnloadRequest( LoadingContext const& loadingContext, EntityModel::ActivationContext& activationContext )
    {
        KRG_ASSERT( m_isUnloadRequested );

        //-------------------------------------------------------------------------

        // Ensure that we also deactivate all entities properly
        if ( IsActivated() )
        {
            Deactivate( loadingContext, activationContext );
        }
        else
        {
            if ( m_status != Status::LoadFailed )
            {
                if ( m_isCollectionInstantiated )
                {
                    // Unload entities
                    for ( auto pEntity : m_entities )
                    {
                        KRG_ASSERT( !pEntity->IsActivated() );
                        pEntity->UnloadComponents( loadingContext );
                    }

                    // Delete instantiated entities
                    DestroyAllEntities();
                    m_isCollectionInstantiated = false;
                }

                // Since entity ownership is transferred via the add call, we need to delete all pending add entity requests
                for ( auto pEntity : m_entitiesToAdd )
                {
                    KRG_ASSERT( !pEntity->HasRequestedComponentLoad() );
                    KRG::Delete( pEntity );
                }
                m_entitiesToAdd.clear();

                // Clear all internal entity lists
                m_entitiesToLoad.clear();
                m_reloadRequests.clear();
                m_entitiesToRemove.clear();
            }

            // Unload the map resource
            if ( !m_isTransientMap )
            {
                loadingContext.m_pResourceSystem->UnloadResource( m_pMapDesc );
            }

            m_status = Status::Unloaded;
            m_isUnloadRequested = false;
            return true;
        }

        return false;
    }

    bool EntityMap::ProcessMapLoading( LoadingContext const& loadingContext, EntityModel::ActivationContext& activationContext )
    {
        KRG_ASSERT( m_status == Status::MapLoading );
        KRG_ASSERT( !m_isTransientMap );

        if ( m_pMapDesc.IsLoading() )
        {
            return false;
        }
        else if ( m_pMapDesc.HasLoadingFailed() )
        {
            m_status = Status::LoadFailed;
        }
        else if ( m_pMapDesc.IsLoaded() )
        {
            if ( m_pMapDesc->IsValid() )
            {
                // Create entities
                {
                    KRG_PROFILE_SCOPE_SCENE( "Create Entity Collection" );
                    auto const& collectionDesc = m_pMapDesc->GetCollectionDescriptor();

                    m_ID = m_pMapDesc->GetID();
                    m_entitiesToLoad.reserve( collectionDesc.GetNumEntityDescriptors() );
                    EntityCollection::CreateAllEntitiesParallel( *loadingContext.m_pTaskSystem, *loadingContext.m_pTypeRegistry, collectionDesc );
                    EntityCollection::ResolveEntitySpatialAttachments( collectionDesc );
                    m_isCollectionInstantiated = true;
                }

                // Load Entities
                for ( auto pEntity : m_entities )
                {
                    pEntity->LoadComponents( loadingContext );
                    m_entitiesToLoad.emplace_back( pEntity );
                }

                m_status = Status::EntitiesLoading;
            }
            else // Invalid map data is treated as a failed load
            {
                m_status = Status::LoadFailed;
            }
        }

        return true;
    }

    void EntityMap::ProcessEntityAdditionAndRemoval( LoadingContext const& loadingContext, EntityModel::ActivationContext& activationContext )
    {
        // Addition
        //-------------------------------------------------------------------------

        // Wait until we have a collection to add the entities too since the map might still be loading
        if ( m_isCollectionInstantiated )
        {
            // Add entities to the collection and request load
            for ( auto pEntityToAdd : m_entitiesToAdd )
            {
                EntityCollection::AddEntity( pEntityToAdd );
                pEntityToAdd->LoadComponents( loadingContext );
                m_entitiesToLoad.emplace_back( pEntityToAdd );
            }

            m_entitiesToAdd.clear();
        }

        // Removal
        //-------------------------------------------------------------------------

        // Unload and deactivate entities and remove them from the collection
        for ( int32 i = (int32) m_entitiesToRemove.size() - 1; i >= 0; i-- )
        {
            auto& removalRequest = m_entitiesToRemove[i];
            auto pEntityToRemove = removalRequest.m_pEntity;

            // Deactivate if activated
            if ( pEntityToRemove->IsActivated() )
            {
                pEntityToRemove->Deactivate( loadingContext, activationContext );
                continue;
            }
            else // Remove from loading list as we might still be loaded this entity
            {
                m_entitiesToLoad.erase_first_unsorted( pEntityToRemove );
                m_reloadRequests.erase_first_unsorted( pEntityToRemove );

                // Unload components and remove from collection
                pEntityToRemove->UnloadComponents( loadingContext );
                EntityCollection::RemoveEntity( pEntityToRemove->m_ID );

                // Destroy the entity if this is a destruction request
                if ( removalRequest.m_shouldDestroy )
                {
                    KRG::Delete( pEntityToRemove );
                }

                // Remove the request from the list
                m_entitiesToRemove.erase_unsorted( m_entitiesToRemove.begin() + i );
            }
        }
    }

    bool EntityMap::ProcessEntityLoadingAndActivation( LoadingContext const& loadingContext, EntityModel::ActivationContext& activationContext )
    {
        struct EntityLoadingTask : public IAsyncTask
        {
            EntityLoadingTask( LoadingContext const& loadingContext, EntityModel::ActivationContext& activationContext, TVector<Entity*>& entitiesToLoad, bool isActivated )
                : m_loadingContext( loadingContext )
                , m_activationContext( activationContext )
                , m_entitiesToLoad( entitiesToLoad )
                , m_isActivated( isActivated )
            {
                m_SetSize = (uint32) m_entitiesToLoad.size();
            }

            virtual void ExecuteRange( TaskSetPartition range, uint32 threadnum ) override final
            {
                KRG_PROFILE_SCOPE_SCENE( "Load and Activate Entities Task" );

                for ( uint32 i = range.start; i < range.end; ++i )
                {
                    auto pEntity = m_entitiesToLoad[i];

                    if ( pEntity->UpdateEntityState( m_loadingContext, m_activationContext ) )
                    {
                        for ( auto pComponent : pEntity->GetComponents() )
                        {
                            KRG_ASSERT( pComponent->IsInitialized() || pComponent->HasLoadingFailed() );
                        }

                        // If the map is activated, immediately activate any entities that finish loading
                        if ( m_isActivated && pEntity->IsLoaded() )
                        {
                            // Prevent us from activating entities whose parents are not yet activated, this ensures that our attachment chain have a consistent activation state
                            if ( !pEntity->HasSpatialParent() || pEntity->GetSpatialParent()->IsActivated() )
                            {
                                pEntity->Activate( m_loadingContext, m_activationContext );
                            }
                        }
                    }
                    else // Entity is still loading
                    {
                        bool result = m_stillLoadingEntities.enqueue( pEntity );
                        KRG_ASSERT( result );
                    }
                }
            }

        public:

            Threading::LockFreeQueue<Entity*>       m_stillLoadingEntities;

        private:

            LoadingContext const&                   m_loadingContext;
            EntityModel::ActivationContext&         m_activationContext;
            TVector<Entity*>&                       m_entitiesToLoad;
            bool                                    m_isActivated = false;
        };

        //-------------------------------------------------------------------------

        {
            KRG_PROFILE_SCOPE_SCENE( "Load and Activate Entities" );

            EntityLoadingTask loadingTask( loadingContext, activationContext, m_entitiesToLoad, IsActivated() );
            loadingContext.m_pTaskSystem->ScheduleTask( &loadingTask );
            loadingContext.m_pTaskSystem->WaitForTask( &loadingTask );

            //-------------------------------------------------------------------------

            // Track the number of entities that still need loading
            size_t const numEntitiesStillLoading = loadingTask.m_stillLoadingEntities.size_approx();
            m_entitiesToLoad.resize( numEntitiesStillLoading );
            size_t numDequeued = loadingTask.m_stillLoadingEntities.try_dequeue_bulk( m_entitiesToLoad.data(), numEntitiesStillLoading );
            KRG_ASSERT( numEntitiesStillLoading == numDequeued );
        }

        //-------------------------------------------------------------------------

        // Ensure that we set the status to loaded, if we were in the entity loading stage and all loads completed
        if ( m_status == Status::EntitiesLoading && m_entitiesToLoad.empty() )
        {
            KRG_ASSERT( !m_isTransientMap );
            m_status = Status::Loaded;
        }

        //-------------------------------------------------------------------------

        return m_entitiesToLoad.empty();
    }

    //-------------------------------------------------------------------------

    bool EntityMap::UpdateState( LoadingContext const& loadingContext, EntityModel::ActivationContext& activationContext )
    {
        KRG_PROFILE_SCOPE_SCENE( "Map Loading" );
        KRG_ASSERT( Threading::IsMainThread() && loadingContext.IsValid() );

        //-------------------------------------------------------------------------

        Threading::RecursiveScopeLock lock( m_mutex );

        //-------------------------------------------------------------------------

        ProcessHotReloadRequests( loadingContext, activationContext );

        //-------------------------------------------------------------------------

        // Process the request and return immediately if it isnt completed
        if ( m_isUnloadRequested )
        {
            if ( !ProcessUnloadRequest( loadingContext, activationContext ) )
            {
                return false;
            }
        }

        //-------------------------------------------------------------------------

        // Wait for the map descriptor to finish loading
        if ( m_status == Status::MapLoading )
        {
            if ( !ProcessMapLoading( loadingContext, activationContext ) )
            {
                return false;
            }
        }

        //-------------------------------------------------------------------------

        ProcessEntityAdditionAndRemoval( loadingContext, activationContext );
        return ProcessEntityLoadingAndActivation( loadingContext, activationContext );
    }
}