#include "System/TypeSystem/TypeRegistry.h"
#include "Applications/Shared/ApplicationGlobalState.h"
#include "Applications/Shared/_AutoGenerated/EngineTypeRegistration.h"
//#include "Applications/Shared/_AutoGenerated/ToolsTypeRegistration.h"
#include <iostream>
#include "Tools/Core/TypeSystem/DynamicTypeInstance.h"
#include "Game/Core/TestComponent.h"
#include "Tools/Entity/ToolEntityCollectionReader.h"
#include "Tools/Entity/ToolEntityCollection.h"
#include "Tools/Entity/ToolEntityCollectionWriter.h"
#include <directxmath.h>

//-------------------------------------------------------------------------

using namespace KRG;

//-------------------------------------------------------------------------

int main( int argc, char *argv[] )
{
    {
        KRG::ApplicationGlobalState State;
        TypeSystem::TypeRegistry typeRegistry;
        AutoGenerated::RegisterTypes( typeRegistry );

        //-------------------------------------------------------------------------

        Serialization::ToolEntityCollectionReader entityCollectionReader( typeRegistry );
        ToolEntityCollection entityCollection( typeRegistry );
        if ( entityCollectionReader.ReadCollection( "D:\\Kruger\\Data\\Maps\\animtest.map", entityCollection ) )
        {
            Serialization::ToolEntityCollectionWriter entityCollectionWriter( typeRegistry );
            entityCollectionWriter.WriteCollection( entityCollection, "D:\\TestMap.map" );
        }

        //-------------------------------------------------------------------------

        Vector u( -32.432f, -54.f, -43.f, -43.f );

        auto f = u.IsAnyLessThan( Vector::Zero );
        auto sgn = u.GetSign();

        Vector a( 23.23232f, 3243.34f, 85.235f );
        Vector b( 3.23232f, 383.1234f, 0.25785f );

        Quaternion rot0( EulerAngles( 23.5f, 54.3f, -75.f ) );
        Vector trans0( 23.5f, -54.3f, 75.f, 1.0f );
        Vector scale0 = Vector( -5, -5, -5, 0.0f );
        //Vector scale0 = Vector( 1.f, 1.f, 1.f, 0.0f );

        Quaternion rot1( EulerAngles( 15.5f, -45.3f, 80.f ) );
        Vector trans1( 12.5f, 74.3f, -1.f, 1.0f );
        Vector scale1 = Vector( 2, -2, -2, 0.0f );
        //Vector scale1 = Vector( 1.f, 1.f, 1.f, 0.0f );

        //-------------------------------------------------------------------------

        Matrix m0( rot0, trans0, scale0 );
        Matrix m1( rot1, trans1, scale1 );

        Quaternion q; 
        Vector t, s;

        m0.Decompose( q, t, s );

        m1.Decompose( q, t, s );

        auto tt = Transform( m0 ); //Transform( q, t, s );
        auto mt = tt.ToMatrix();

        //auto m = m1 * m0;

        //auto mr = m.GetRotation();
        //auto me = mr.ToEulerAngles();
        //auto ms = m.GetScale();
        //auto mt = m.GetTranslation();

        ////-------------------------------------------------------------------------

        //auto dm0 = DirectX::XMMatrixAffineTransformation( (DirectX::XMVECTOR&) scale0, { 0, 0, 0, 0 }, ( DirectX::XMVECTOR& ) rot0, ( DirectX::XMVECTOR& ) trans0 );
        //auto dm1 = DirectX::XMMatrixAffineTransformation( (DirectX::XMVECTOR&) scale1, { 0, 0, 0, 0 }, ( DirectX::XMVECTOR& ) rot1, ( DirectX::XMVECTOR& ) trans1 );

        //auto dm = DirectX::XMMatrixMultiply( dm1, dm0 );

        ////-------------------------------------------------------------------------

        //Transform t0( rot0, trans0, scale0 );
        //Transform t1( rot1, trans1, scale1 );

        //auto t = t1 * t0;
        //auto tm = t.ToMatrix();

        //auto t1_calc = Transform::Delta( t0, t );
        //auto t_calc = t1_calc * t0;

        ////-------------------------------------------------------------------------

        //Vector da = (Vector&) DirectX::XMVector3Transform( { 23.23232f, 3243.34f, 85.235f }, dm );
        //auto mta = m.TransformPoint( a );
        //auto tta = t.TransformPoint( a );

        //KRG_ASSERT( da.IsNearEqual3( mta, Math::HugeEpsilon ) );
        //KRG_ASSERT( mta.IsNearEqual3( tta, Math::HugeEpsilon ) );

        {
            

            //Quaternion dr;
            //Vector dt;
            //Vector ds;
            //m.Decompose( dr, dt, ds );

            

            //Quaternion QA = Quaternion( EulerAngles( 0, 0, 15 ) );
            //Quaternion QB = Quaternion( EulerAngles( 0, 0, 30 ) );

            //Transform ta = Transform( QA, Vector( 0, 1, 0 ) );
            //Transform tb = Transform( QB, Vector( 0, 10, 0 ) );
            //Transform tx = Transform::Delta( ta, tb );
            //Transform tx2 = Transform::DeltaNoScale( ta, tb );

            //auto e0 = tx.ToEulerAngles();
            //auto e1 = tx2.ToEulerAngles();

            //auto tc = tx.GetRotation() * ta.GetRotation();
            //auto tc2 = tx * ta;

            ////-------------------------------------------------------------------------

            //auto ma = m.TransformPoint( a );
            //auto mb = m.TransformPoint( b );

            //auto ta = t.TransformPoint( a );
            //auto tb = t.TransformPoint( b );
        }

        //-------------------------------------------------------------------------

        AutoGenerated::UnregisterTypes( typeRegistry );
    }
    return 0;
}
