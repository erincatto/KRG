#include "System/TypeSystem/TypeRegistry.h"
#include "Applications/Shared/ApplicationGlobalState.h"
#include "Applications/Shared/_AutoGenerated/EngineTypeRegistration.h"
//#include "Applications/Shared/_AutoGenerated/ToolsTypeRegistration.h"
#include <iostream>
#include "Tools/Core/TypeSystem/toolTypeInstance.h"
#include "Game/Core/TestComponent.h"
#include "Tools/Entity/ToolEntityCollectionConverter.h"
#include "Tools/Entity/ToolEntityCollection.h"
#include <directxmath.h>
#include "System/TypeSystem/CoreTypeValidation.h"
#include "System/Entity/EntityDescriptors.h"
#include "System/Core/Types/UUID.h"
#include "Game/Core/PlayerController/DefaultPlayerController.h"
#include "System/Core/Serialization/BinaryArchive.h"

#include "Engine/Render/Material/RenderMaterial.h"
#include "System/Core/Types/Event.h"
#include "System/Core/Memory/MemoryStreamHelpers.h"
#include "System/Core/Time/Timers.h"

//-------------------------------------------------------------------------

using namespace KRG;

//-------------------------------------------------------------------------

int main( int argc, char *argv[] )
{
    {
        KRG::ApplicationGlobalState State;
        TypeSystem::TypeRegistry typeRegistry;
        AutoGenerated::RegisterTypes( typeRegistry );

        //-------------------------------------------------------------------------

        //Serialization::ToolEntityCollectionReader entityCollectionReader( typeRegistry );
        //ToolEntityCollection entityCollection( typeRegistry );
        //if ( entityCollectionReader.ReadCollection( "D:\\Kruger\\Data\\Maps\\animtest.map", entityCollection ) )
        //{
        //    Serialization::ToolEntityCollectionWriter entityCollectionWriter( typeRegistry );
        //    entityCollectionWriter.WriteCollection( entityCollection, "D:\\TestMap.map" );
        //}

        ////-------------------------------------------------------------------------

        //Vector u( -32.432f, -54.f, -43.f, -43.f );

        //auto f = u.IsAnyLessThan( Vector::Zero );
        //auto sgn = u.GetSign();

        //Vector a( 23.23232f, 3243.34f, 85.235f );
        //Vector b( 3.23232f, 383.1234f, 0.25785f );

        //Quaternion rot0( EulerAngles( 23.5f, 54.3f, -75.f ) );
        //Vector trans0( 23.5f, -54.3f, 75.f, 1.0f );
        //Vector scale0 = Vector( -5, -5, -5, 0.0f );
        ////Vector scale0 = Vector( 1.f, 1.f, 1.f, 0.0f );

        //Quaternion rot1( EulerAngles( 15.5f, -45.3f, 80.f ) );
        //Vector trans1( 12.5f, 74.3f, -1.f, 1.0f );
        //Vector scale1 = Vector( 2, -2, -2, 0.0f );
        ////Vector scale1 = Vector( 1.f, 1.f, 1.f, 0.0f );

        ////-------------------------------------------------------------------------

        //Matrix m0( rot0, trans0, scale0 );
        //Matrix m1( rot1, trans1, scale1 );

        //Quaternion q; 
        //Vector t, s;

        //m0.Decompose( q, t, s );

        //m1.Decompose( q, t, s );

        //auto tt = Transform( m0 ); //Transform( q, t, s );
        //auto mt = tt.ToMatrix();

        //auto m = m1 * m0;

        //auto mr = m.GetRotation();
        //auto me = mr.ToEulerAngles();
        //auto ms = m.GetScale();
        //auto mt = m.GetTranslation();

        ////-------------------------------------------------------------------------

        //auto dm0 = DirectX::XMMatrixAffineTransformation( (DirectX::XMVECTOR&) scale0, { 0, 0, 0, 0 }, ( DirectX::XMVECTOR& ) rot0, ( DirectX::XMVECTOR& ) trans0 );
        //auto dm1 = DirectX::XMMatrixAffineTransformation( (DirectX::XMVECTOR&) scale1, { 0, 0, 0, 0 }, ( DirectX::XMVECTOR& ) rot1, ( DirectX::XMVECTOR& ) trans1 );

        //auto dm = DirectX::XMMatrixMultiply( dm1, dm0 );

        ////-------------------------------------------------------------------------

        //Transform t0( rot0, trans0, scale0 );
        //Transform t1( rot1, trans1, scale1 );

        //auto t = t1 * t0;
        //auto tm = t.ToMatrix();

        //auto t1_calc = Transform::Delta( t0, t );
        //auto t_calc = t1_calc * t0;

        ////-------------------------------------------------------------------------

        //Vector da = (Vector&) DirectX::XMVector3Transform( { 23.23232f, 3243.34f, 85.235f }, dm );
        //auto mta = m.TransformPoint( a );
        //auto tta = t.TransformPoint( a );

        //KRG_ASSERT( da.IsNearEqual3( mta, Math::HugeEpsilon ) );
        //KRG_ASSERT( mta.IsNearEqual3( tta, Math::HugeEpsilon ) );

        {
            

            //Quaternion dr;
            //Vector dt;
            //Vector ds;
            //m.Decompose( dr, dt, ds );

            

            //Quaternion QA = Quaternion( EulerAngles( 0, 0, 15 ) );
            //Quaternion QB = Quaternion( EulerAngles( 0, 0, 30 ) );

            //Transform ta = Transform( QA, Vector( 0, 1, 0 ) );
            //Transform tb = Transform( QB, Vector( 0, 10, 0 ) );
            //Transform tx = Transform::Delta( ta, tb );
            //Transform tx2 = Transform::DeltaNoScale( ta, tb );

            //auto e0 = tx.ToEulerAngles();
            //auto e1 = tx2.ToEulerAngles();

            //auto tc = tx.GetRotation() * ta.GetRotation();
            //auto tc2 = tx * ta;

            ////-------------------------------------------------------------------------

            //auto ma = m.TransformPoint( a );
            //auto mb = m.TransformPoint( b );

            //auto ta = t.TransformPoint( a );
            //auto tb = t.TransformPoint( b );
        }

     
        //
        //EntityModel::PropertyDescriptor p;
        //p.m_path = TypeSystem::PropertyPath( "m_transform" );
        //p.SetByteValue( t );

        //EntityModel::EntityComponentDescriptor c;
        //c.m_ID = KRG::UUID::GenerateID();
        //c.m_name = StringID( "CameraComponent" );
        //c.m_typeID = CameraComponent::GetStaticTypeID();
        //c.m_isSpatialComponent = true;
        //c.m_propertyValues.emplace_back( p );

        //EntityModel::EntitySystemDescriptor s;
        //s.m_typeID = DefaultPlayerController::GetStaticTypeID();

        //EntityModel::EntityDescriptor e;
        //c.m_ID = KRG::UUID::GenerateID();
        //c.m_name = StringID( "Player" );
        //e.m_components.emplace_back( c );
        //e.m_systems.emplace_back( s );


     /*   TVector<Byte> m_buffer;
        m_buffer.resize( sizeof( t ) );

        {
            Serialization::BinaryArchive archive( Serialization::Mode::Write, m_buffer );
            archive << t;
        }

        {
            Serialization::BinaryArchive archive( Serialization::Mode::Read, m_buffer );
            archive >> s;
        }*/


        TVector<Byte> arr;
        String t = "data://dasdsadasddsadasadasdsadasdasdaadadsadasd adsadsaddas dsadasdasdasddsadasd asdasdasdasdasdasdasdasdsadsadas dsadassssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss.map";

        Timer perfTimer;
        for ( auto i = 0; i < 100; i++ )
        {
            Serialization::BinaryMemoryArchive archive( Serialization::Mode::Write, arr );

            //Serialization::BinaryWriter archive( arr );
            archive << t;

            //-------------------------------------------------------------------------

            /*auto pOutStream = KRG::New<MemoryStream>( arr );
            auto pArchive = KRG::New<cereal::BinaryOutputArchive>( *pOutStream );
            ( *pArchive ) << t;
            KRG::Delete( pArchive );
            KRG::Delete( pOutStream );*/

            //-------------------------------------------------------------------------

            arr.clear();
            //arr.shrink_to_fit();
        }

        Milliseconds elapsedTime = perfTimer.GetElapsedTimeMilliseconds();

        //-------------------------------------------------------------------------

        AutoGenerated::UnregisterTypes( typeRegistry );
    }
    return 0;
}
