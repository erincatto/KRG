#include "ResourceCompilerManager.h"
#include "System/Core/FileSystem/FileSystem.h"
#include "System/Core/Settings/ConfigSettings.h"
#include "Applications/Shared/_AutoGenerated/ToolsTypeRegistration.h"

//-------------------------------------------------------------------------

namespace KRG::Resource
{
    namespace Settings
    {
        static ConfigSettingString g_sourceDataPath( "SourceDataPath", "Paths", "" );
        static ConfigSettingString g_compiledDataPath( "CompiledDataPath", "Paths", "" );
    }

    //-------------------------------------------------------------------------

    ResourceCompilerManager::ResourceCompilerManager()
    {
        FileSystem::Path const workingDirectoryPath = FileSystem::GetCurrentProcessPath();
        m_sourceDataPath = workingDirectoryPath + Settings::g_sourceDataPath;
        m_compiledDataPath = workingDirectoryPath + Settings::g_compiledDataPath;

        KRG_ASSERT( m_sourceDataPath.IsValid() && m_compiledDataPath.IsValid() );

        FileSystem::EnsurePathExists( m_sourceDataPath );
        FileSystem::EnsurePathExists( m_compiledDataPath );

        //-------------------------------------------------------------------------

        AutoGenerated::RegisterTypes( m_typeRegistry );

        UpdateCompilerTypeMap( m_animationModule.GetRegisteredCompilers() );
        UpdateCompilerTypeMap( m_renderModule.GetRegisteredCompilers() );
        UpdateCompilerTypeMap( m_physicsModule.GetRegisteredCompilers() );
        UpdateCompilerTypeMap( m_entityModule.GetRegisteredCompilers() );
    }

    ResourceCompilerManager::~ResourceCompilerManager()
    {
        AutoGenerated::UnregisterTypes( m_typeRegistry );
    }

    void ResourceCompilerManager::UpdateCompilerTypeMap( TVector<Resource::Compiler*> const& compilers )
    {
        for ( auto& pCompiler : compilers )
        {
            auto const& resourceTypes = pCompiler->GetOutputTypes();
            for ( auto& type : resourceTypes )
            {
                // Two compilers registering for the same resource type is not allowed
                KRG_ASSERT( m_compilerTypeMap.find( type ) == m_compilerTypeMap.end() );
                m_compilerTypeMap.insert( TPair< ResourceTypeID, Resource::Compiler*>( type, pCompiler ) );
            }
        }
    }

    CompilationResult ResourceCompilerManager::Compile( ResourceID const& resourceToCompile )
    {
        KRG_ASSERT( resourceToCompile.IsValid() );

        //-------------------------------------------------------------------------

        CompileContext compileContext( m_typeRegistry, m_sourceDataPath, m_compiledDataPath, resourceToCompile );
        if ( !compileContext.IsValid() )
        {
            return CompilationResult::Failure;
        }
        //-------------------------------------------------------------------------

        if ( !compileContext.m_inputFilePath.Exists() )
        {
            KRG_LOG_ERROR( "ResourceCompiler", "Source file for data path ('%s') does not exist: '%s'\n", m_sourceDataPath.c_str(), compileContext.m_inputFilePath.c_str() );
            return CompilationResult::Failure;
        }

        //-------------------------------------------------------------------------

        auto compilerTypeIter = m_compilerTypeMap.find( compileContext.m_resourceID.GetResourceTypeID() );
        if ( compilerTypeIter == m_compilerTypeMap.end() )
        {
            KRG_LOG_ERROR( "ResourceCompiler", "Cant find appropriate resource compiler for type: %u", compileContext.m_resourceID.GetResourceTypeID() );
            return CompilationResult::Failure;
        }

        //-------------------------------------------------------------------------

        auto pCompiler = compilerTypeIter->second;
        return pCompiler->Compile( compileContext );
    }
}